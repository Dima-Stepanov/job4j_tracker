1.2.7. Контрольные вопросы
1.Экзамен. ООП.[#791#127073]

1. Что такое ООП?

Объе́ктно-ориенти́рованное программи́рование (ООП) 
— методология программирования,
основанная на представлении программы в виде совокупности объектов,
каждый из которых является экземпляром определённого класса,
а классы образуют иерархию наследования.

2. Базовые концепции ООП?

* полиморфизм - переодределение данных
* абстракция - описание лишь скелета объекта без реализации
* инкапсуляция - защита данных от внешнего доступа к ним
* наследование - возможность наследовать данные из классов-родителей


3. Укажите из каких элементов состоит класс.

* Поля - общие переменные в классе
* Конструктор - моежет и не быть в этом случае используется 
конструктор по умолчанию без параметров 
* Методы - в них содержится основной функционал класса.

4. Что такое конструктор?

Конструктор — это специальный метод,
который вызывается при создании нового объекта (всегда вызывается совместно с операцией new). 
Конструктор нужен для автоматической инициализации переменных,
т.е. он инициализирует объект непосредственно во время создания. 
Имя конструктора совпадает с именем класса, 
включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения void.

Конструктор — это блок кода, который позволяет вам создать объект класса и имеет то же имя, что и класс, без явного возвращаемого типа.

5. Можно ли наследовать конструктор?

Всякий раз, когда класс (дочерний класс) расширяет другой класс (родительский класс), подкласс наследует состояние и поведение в виде переменных и методов от своего суперкласса, но не наследует конструктор суперкласса по следующим причинам:

Конструкторы являются специальными и имеют то же имя, что и имя класса. Таким образом, если бы конструкторы были унаследованы в дочернем классе, тогда дочерний класс содержал бы конструктор родительского класса, который противоречит ограничению, что конструктор должен иметь то же имя, что и имя класса.

Кратко - Нет, но ему можно передать аргументы с помощью super.
В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. Конструкторы не являются членами, поэтому они не наследуются, но конструктор суперкласса м.б. вызван из подкласса.

6. Что такое перегрузка конструктора?

Перегрузка конструктора - это создание конструкторов с другим набором аргументов (как по количеству, так и по порядку следования).

Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов класса.

Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то его нужно создать явно.

7. Что такое статический метод?

Статический метод - это метод, который можно вызвать без создания объекта, 
напрямую через имя класса.

Статичекий метод нельзя переопределять. Он "один" для класса и его наследников.

Статические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом".

В отличие от локальных переменных статические поля и методы не потокобезопасны в Java.


8. Что такое не статический метод?

Не статический метод - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и может быть вызван с помощью ссылки на данный объект.

9. Для чего используется ключевое слово this?
		В Java слово this используется в двух разных значениях. 
	1) Когда оно используется как переменная объектного типа, типа this.value = 5;, оно означает тот объект, к которому относится код, использующий this. Используется это для разрешения неоднозначности, когда, например, есть поле объекта и локальная переменная с одинаковыми именами, тогда просто qq++ означает инкремент локальной переменной qq, а this.qq++ означает инкремент одноименного поля объекта. Иногда может использоваться просто для повышения читабельности. Довольно часто можно встретить такое его использование в конструкторах, когда имена параметров конструктора совпадают с именами полей, такого вот типа:

			class Person {
			  private String name; // Поля объекта
			  private int age;

		  // Создаём объект с заданными значениями полей
		  public Person(String name, int age) { // При вызове зададим начальные значения в виде параметров
			this.name = name;  // Значения этих параметров 
			this.age = age;    // присваиваются переменным объекта
		  }
		}

Понятно, что в статических методах его использовать нельзя, так как статические методы не принадлежат какому-то отдельному объекту.

	2) Оно может использоваться в конструкторе в форме вызова метода, типа this(someValue), и тогда оно означает вызов другого конструктора этого же класса. Используется для сокращения кода, когда двум разным конструкторам нужно выполнить одни и те же действия, напр.

			class Person {
			  private String name; // Поля объекта
			  private int age;

			  public Person(String name, int age) { // Создаём объект с заданными значениями полей
				this.name = name;  // Значения параметров 
				this.age = age;    // присваиваются переменным объекта
			  }

			  public Person() { // Создаём объект с некими дефолтными значениями 
				this("NoName", -1);  // Вызов другого конструктора
			  }

			}

В этом примере задача второго конструктора -- просто обеспечить какие-то значения полей, если их не предоставил пользователь. С этими значениями второй конструктор вызывает первый конструктор, который присваивает полученные значения соответствующим полям.

									 this - это неявный первый параметр любого нестатического метода класса. У какого объекта вызывается метод, тот и будет передан в качестве параметра this.

									соответственно, this используется:

										в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса. Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.

									class Student {
										int age;
										Student (int age) {
											this.age = age;
										}
									}

										когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризированном). Вызов this() может находиться только в первой строке конструктора.

									public class Toy {
										String name;
										int cost;
										String manufacturer;
										int age;

										public Toy(String name, int cost, String manufacturer, int age) {
											this(name, cost, manufacturer);
											this.age = age;
											System.out.println("В конструкторе с четырьмя параметрами");
										}

										public Toy(String name, int cost, String manufacturer) {
											this();
											this.name = name;
											this.cost = cost;
											this.manufacturer = manufacturer;
											System.out.println("В конструкторе с тремя параметрами");
										}

										public Toy() {
											System.out.println("В конструкторе по умолчанию");
										}
									}
									public class ToyDemo {
										public static void main(String[] args) {
											Toy toy = new Toy("Кукла", 34, "Disney", 3);
										}
									}

									вывод:

									В конструкторе по умолчанию
									В конструкторе с тремя параметрами
									В конструкторе с четырьмя параметрами



10. Какой класс является базовый родительным классов для всех классов?

		Object - корневой класс в иерархии классов Java.

		Все непримитивный типы, включая массивы, наследуют прямо или косвенно от него. Поэтому ссылочная переменная класса Object может ссылаться на объект любого другого класса.

		Ключевое слово super представляет текущий экземпляр родительского класса.

11. Что такое наследование? Приведите примеры из реальной жизни.

		Наследование — это процесс перенимания классом свойств (методов и полей) другого класса. С использованием в Java наследования информация становится управляемой в иерархическом порядке. Класс, который наследует свойства другого класса, называется подклассом (производным классом, наследующим классом), а класс, свойства которого наследуются, известен как суперкласс (базовый класс, родительский класс).

		Это когда один объект перенимает все публичные поля и методы другого объекта.

		Автомобили -> Легковые -> Модель1, Модель2.

		Млекопитающие -> Киты -> Голубой кит, горбатый кит.
		
		Для наследование в Java используется слово extends после имени наследника.

12. Опишите процесс создания нового объекта.

					https://java-blog.ru/osnovy/sozdanie-obekta-java 

					Java – это объектно-ориентированный язык. Другими словами, почти все в Java рассматривается как объект.
					Использование ключевого слова «new»

					При программировании вы наверняка сталкивались с ключевым словом «new», используемым для создания объекта, которому динамически выделяется память, т.е. память этим объектам выделяется во время выполнения. И это динамическое распределение требуется большую часть времени при создании объектов. Следовательно, этот метод используется чаще, чем другие.
					Синтаксис

					ClassName ObjectName = new classConstructor();
					Пример
					public class ObjectCreation {
					   String FirstString = "Hello World";
					   public static void main(String[] args)
					   {
						   ObjectCreation obj = new ObjectCreation();
						   System.out.println(obj.FirstString);
					   }
					}

					Выход – Hello World

					Этот метод создания объектов в Java может использоваться с любым конструктором требуемого класса, если класс имеет более одного конструктора.
					Использование метода clone()

					Что если объект, который мы хотим создать, должен быть копией уже существующего ? В этом случае мы можем использовать метод clone(), он – часть класса Object, но его нельзя использовать напрямую, поскольку является защищенным методом.

					Метод clone() можно использовать только после реализации интерфейса Cloneable и обработки исключения CloneNotSupportedException.
					Пример
					class Message implements Cloneable
					{
					   String FirstString;
					   Message() {
						   this.FirstString = "Hello World";
					   }
					   public Object clone() throws
							   CloneNotSupportedException
					   {
						   return super.clone();
					   }
					}
					public class ObjectCreation {
					   public static void main(String[] args) throws
							   CloneNotSupportedException
					   {
						   Message FirstObj = new Message();
						   System.out.println(FirstObj.FirstString);


						   Message SecondObj = (Message)FirstObj.clone();
						   System.out.println(SecondObj.FirstString);
						   SecondObj.FirstString = "Welcome to the world of programming";
						  
						   System.out.println(SecondObj.FirstString);
						   System.out.println(FirstObj.FirstString);
						 
					   }
					}
					Вывод

					Hello World

					Hello World

					Welcome to the world of programming

					Hello World

					В приведенной выше программе мы создали копию нашего уже существующего объекта. Чтобы обе переменные не указывали на одну и ту же ячейку памяти, было важно изменить значение «FirstString» для второго объекта, а затем распечатать его значение для обоих объектов.
					Использование метода newInstance() класса Class

					Этот метод не часто используется для создания объектов, в случаях, когда мы знаем имя класса, а конструктор по умолчанию является публичным по своей природе. Чтобы использовать его, нам нужно обработать 3 исключения

						ClassNotFoundException – это исключение происходит, если JVM не может найти класс, который передается в качестве аргумента.
						InstantiationException – это исключение возникает, если данный класс не содержит конструктор по умолчанию.
						IllegalAccessException – это исключение происходит, если у нас нет доступа к указанному классу.

					Пример
					class ObjectCreation{
					   String FirstString = "Hello World";
					   public static void main(String[] args)
					   {
						   try
						   {
							   Class Message = Class.forName("ObjectCreation");
							   ObjectCreation obj =
									   (ObjectCreation) Message.newInstance();
							   System.out.println(obj.FirstString);
						   }
						   catch (ClassNotFoundException e)
						   {
							   e.printStackTrace();
						   }
						   catch (InstantiationException e)
						   {
							   e.printStackTrace();
						   }
						   catch (IllegalAccessException e)
						   {
							   e.printStackTrace();
						   }
					   }
					}

					Выход – Hello World
					Использование десериализации

					В Java сериализация используется для преобразования текущего состояния объекта в поток байтов. десериализация является полной противоположностью, поскольку мы воссоздаем объект, используя поток байтов. Для процесса сериализации нам необходимо реализовать интерфейс Serializable.

					Обработка исключений должна быть сделана для создания объектов с использованием этого метода.
					ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
					Classname object = (classname) objectInputStream.readObject();
					Использование метода newInstance() класса Constructor

					Мы увидели метод newInstance класса Class, который мы использовали для создания объекта. Точно так же конструктор класса также состоит из метода newInstance(), который можно использовать для создания объектов. Другие могут использовать конструкторы Java по умолчанию с помощью этого метода, мы также можем вызвать параметризованные конструкторы.
					import java.lang.reflect.*;
					public class ObjectCreation
					{
					   private String FirstString = "Hello World";
					   ObjectCreation()
					   {
					   }
					   public void changeMessage(String message)
					   {
						   this.FirstString = message;
					   }
					   public static void main(String[] args)
					   {
						   try
						   {
							   Constructor<ObjectCreation> constructor = ObjectCreation.class.getDeclaredConstructor();
							   ObjectCreation objectCreation = constructor.newInstance();
							   objectCreation.changeMessage("Welcome to the world of programming");
							   System.out.println(objectCreation.FirstString);
						   }
						   catch (Exception e)
						   {
							   e.printStackTrace();
						   }
					   }
					}

					Вывод:

					Welcome to the world of programming.

					Это 5 различных способов создания объектов в Java, которые используются чаще других. Каждый метод имеет свои преимущества и недостатки. В конце концов, выбор за вами.
					
		Eще вариант
		Объект создается с помощью ключевого слова new, которое вызывает конструктор класса, который инициализирует начальное состояние объекта.

	Book b;         // объявление переменной определенного типа/класса
	b = new Book(); // инстационирование/создание (выделение памяти под объект) и инициализация объекта;

	Кроме конструктора начальную инициализацию объекта можно проводить с помощью инициализатора объекта (блока инициализации). Инициализатор выполняется до любого конструктора. Т.е. в инициализатор мы можем поместить код, общий для всех конструкторов.

	Последовательность инициализации блоков класса и его родителя:

    Сначала вызываются все статические блоки от первого предка до последнего наследника.
    Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка).


13. Как вызвать метод из родительского класса?
		Если метод родительского класса переопределен, а нужно вызвать оригинальную версию метода, то нужно использовать ключевое слово super, которое представляет текущий экземпляр родительского класса.
14. Что такое переопределение метода?
		Это возможность задать методу родительского класса другой функционал.

		При этом сигнатура (имя метода плюс параметры, причем порядок параметров имеет значение) метода и тип возвращаемого значения должны совпадать с сигнатурой и типом возврата в базовом классе.
		https://habr.com/ru/company/otus/blog/347900/

15. Можно ли переопределить статический метод?
	Нет, статический метод создается при инициализации класса один на все объекты.
16. Что такое виртуальная функция и используются ли они в Java?
		Поведение виртуальной функции может быть переопределено наследующей функцией класса с тем же именем. Она в основном определяется в базовом классе и переопределяется в унаследованном классе.

		Ожидается, что виртуальная функция будет определена в производном классе. Мы можем вызвать виртуальную функцию, ссылаясь на объект производного класса, используя ссылку или указатель базового класса.

		Каждый нестатический метод по умолчанию является виртуальным методом. В Java нет виртуального ключевого слова, такого как C ++, но мы можем определить его и использовать для таких понятий, как полиморфизм во время выполнения.
		
		Виртуальная функция - это функция (метод), которая может быть переопределена наследником.

		В Java практически все функции виртуальные (private функции не могут быть переопределены в связи с правами видимости)

17. Что такое перегрузка метода?

	Перегрузка метода - это наличие в классе нескольких методов с одним именем, но разными наборами параметров.

	Перегрузить можно не только метод, но и конструктор.

	При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые указываются при вызове.

18. Можно ли изменить тип возвращаемых данных при перегрузке метода?
	Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать.

	Т.е. если меняем тип возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.
	https://habr.com/ru/company/otus/blog/347900/

19. Что такое множественное наследование? Как его можно реализовать в Java.

		Множественное наследование - это наследование класса от нескольких суперклассов одновременно.

		В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы.
				  A
     			 / \
				B   C
				 \ /
				  D	

		возникает неоднозначность: если метод класса D вызывает метод класса А (и этот метод не переопределён в классе D), а классы B и C по своему переопределили этот метод, то от какого класса его наследовать? от B или C?

	    В Java множественное наследование поддерживают интерфейсы.

		Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией. Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые обращаются к нужным методам этих объектов. И наследоваться от этого класса.

20. Что такое полиморфизм? Приведите примеры из реальной жизни.

		Полиморфизм - позволяет достигнуть взаимозаменяемости. То есть часть программы не имеет жесткой связи и ее можно заменить на другую программу. Полиморфизм окружает нашу жизнь. Например: компьютер и его отдельные детали или пример из программирования - это ваша программа и база данных.

		Полиморфизм в Java достигается за счет использования сущности interface. 

		Интерфейсы обладают особыми свойствами.

		1. Не могут хранить состояния. Внутри интерфейса нельзя создать поля для сохранения в них данных.

		2. Могут иметь множественное наследование. В java нет множественного наследования относительно классов. Зато в интерфейсах такая возможность есть.

		3. Объявление методов без реализации. По сути это и есть контракт, как должен работать тот или иной объект, чтобы он мог использоваться в другой системе.

		Например, USB вход. Универсальный интерфейс. С помощью него можно подключить любое устройство. Причем можно как читать данные, так и просто заряжать устройство. 

		4. Реализация методов. По сути интерфейс - это тот же класс без состояния с возможностью множественного наследования. 
		
		Полиморфизм описывают выражением: Один интерфейс - множество реализаций.

		Полиморфизм - это возможность работать с несколькими типами, как будьто это один и тот же тип, в то же время поведение каждого типа будет уникальным в зависимости от его реализации.

21. Что такое инкапсуляция?
		инкапсуляция или закрытие
		Этот механизм позволяет скрыть реализацию кода класса от пользователя этого класса. А зачем что-то скрывать? 
		Пользователь класса может записать данные или вызвать методы, которые повлекут ошибку в работе этого класса. Механизм инкапсуляции позволяет запретить обращаться к методам или полям. 
		Инкапсуляция - этот механизм используется для скрытия реализации устройства объекта от пользователей этого класса. Этот механизм позволяют относиться к объекту, как к атомарному элементу. Представьте, если бы постоянно думали о том, как в памяти сохранить массив или строку. За нас это делает виртуальная машина.
	
		
22. Как реализована инкапсуляция в Java? 
	В java полиморфизм достигается за счет модификаторов доступа.
	Модификаторов всего 4: public, protected, default и private. 
	Модификатор доступа располагается вначале элемента: класса, конструктора, метода, поля класса. К локальным переменным модификаторы не применяются. 
 
	public - элемент обозначенный этим модификатором доступа доступен везде в программе.
 
	protected - элемент обозначенный этим модификатором доступа доступен внутри пакета и в наследниках.
 
	default - элемент обозначенный этим модификатором доступа доступен внутри пакета.
 
	private - элемент обозначенный этим модификатором доступа доступен внутри класса.
 
			В этом курсе есть правило, что мы применяем только два модификатора public и private.
		Почему так? Модификаторы default и protected связаны с тонкостями проектирования. В большинстве случаев программист ошибается с выбором этих модификаторов и в дальнейшем изменяет существующий код. Так же модификаторы default и protected соблазняют программиста делать расширение кода за счет наследования. Этот механизм жестко связывает элементы. Далее в курсе мы увидим возникающую из этого проблему.
		 
		Поэтому общее правило в курсе.
		 
		1. Для всех полей используем только модификатор private.
		2. Для классов - public. Во второй и третьей части курса так же применим для классов private.
		3. Для методов - public или private. Общее правило, если метод имеет модификатор default или protected его нужно переделать на public

23. Можно ли применить модификаторы доступ к конструкторам?
	Да можно. С целью ограничить создания экземпляра класса. Например в патерне Singelton конструктор класса private, этом его вызов организован через специальный метод.
24. Что такое интерфейс?
	Interface  - это элемент, который содержит объявления методов, но не содержит реализации этих методов. Интерфейс будет определять, что должен делать класс, но он не знает как. 
	Интерфейс создается по аналогии с классом но имеет вид:
	public interface Input {}
		Создайте класс ru.job4j.memTracker.StubInput. Чтобы этот класс начал использовать интерфейс нам нужно после имени класс дописать следующие строчки.

		implements Input - эта строчка заставляет нас в классе StubInput создать те же методы, что и в интерфейсе Input и добавить в них реализацию.
		
		У интерфейсов нет конструкторов.

			Инерфейс позволяет создавать общий тип данных для разных объектов, т.е. использование интерфейса гарантирует наличие определенного метода у объекта.

			При реализации интерфейса класс реализовать все его методы, иначе он должен быть помечен как abstract.

			Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.

			Абстрактный класс vs интерфейс

			Абстрактный класс содержит состояние объекта, что в интерфейсе невозможно, т.к. поля там являются константами

			Наследовать extends можно только один абстрактный класс, а реализовать implements интерфейсов сколько угодно. Интерфейс может наследовать другой интерфейс.

			В интерфейсах нет конструкторов.

			Замечание:

			Абстрактные классы используются, когда есть отношение is-a, т.е. класс наследник расширяет базовый абстрактный класс. Интерфейс же могут быть реализованы разными классами, вовсе не связанными друг с другом.

			Поэтому код, написанный на интерфейсах более масштабируем и его легче поддерживать. При использовании абстрактных классов, а это всегда наследование, мы связываем наш код.
		
25. Какие типы исключительных ситуаций бывают?

	Java все исключения делятся на два типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception). Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).
	Все исключения в Java можно представить в виде дерева.
					________[Throwable]______
					|						|
				[Exeption]				[Error]
					|
			--------------------
			|					|
	[Hendle exception]    [Unhandle exeption]
	
	
	Важно!!! В чем же состоит разница между проверяемыми и не проверяемыми исключениями?

	- проверяемыми являются исключения, которые проверяются во время компиляции программы и если такие исключения не обработать, то наша программа попросту не скомпилируется. Для обработки исключения используется блок try-catch или ключевое слово throws после сигнатуры метода. К таким исключениям относятся: готовые исключения подклассов IOException, SQLException, а также все пользовательские исключения, которые мы наследуем от класса Exception;

	- соответственно непроверяемыми исключениями являются исключения, которые проверяются во время запуска программы (Runtime), т.е. если их не обработать с помощью конструкции try-catch, то наш код скомпилируется без всяких проблем. К непроверяемым исключениям относятся все наследники класса RuntimeException.
	Почему нежелательно отлавливать RuntimeException? Потому, что эти исключения относятся к логическим ошибкам в коде и их нужно устранить за счет поиска ошибки в коде, а не за счет обработки исключения.
	
	для создания пользовательского исключения необходима создать класс и унаследовать его от класса Exeption
	при этом переопредилить конструктор с указанием причины ошибки.
	public class UserInputException extends Exception {
    public UserInputException(String message) {
        super(message);
    }}
			Объявления исключений в сигнатуре метода.

		В Java есть ключевое слово throws. Его можно добавить после параметров метода и указать, какие прерывания могут случиться с этим методом.

		public static void load(String url) throws UserInputException {
			if (url == null) {
				throw new UserInputException("Url could not be null");
			}
			/*load jdbc*/
		}

		Через запятую можно указать несколько исключений. В этом случае мы передаем ответственность за исключение коду, который будет использовать наш метод.
			Чтобы прервать выполнение программы, нужно использовать оператор throw с передачей этому оператору объекта типа java.util.Exception.
			 public static int add(int start, int finish) {
				if (start > finish) {
					throw new IllegalArgumentException("Start should be less than finish.");
				}
				
				В Java есть встроенные классы, которые описывают исключительные ситуации. Старайтесь не создавать свои исключения, а использовать встроенные. Это позволит другим программистам быстрее понять причину возникновения проблемы.

		В конструкторе исключения нужно обязательно указать причину возникновения исключения. Никогда не оставляйте текст пустым.

		java.lang.IllegalArgumentException - метод вызывается с некорректными параметрами.

		java.lang.IllegalStateException - метод вызывается с объекта в не корректном состоянии.

		java.lang.NullPointerException - методы вызывается у переменной, которая инициализирована null ссылкой.
		
		Unhandled exception - необработанное исключение. Если мы используем в коде классы не имеющие в иерархии наследования java.langRuntimeException, то их нужно обрабатывать.

		Существует два способа обработки исключений.

		Объявления исключений в сигнатуре метода.

		В Java есть ключевое слово throws. Его можно добавить после параметров метода и указать, какие прерывания могут случиться с этим методом.

		public static void load(String url) throws UserInputException {
			if (url == null) {
				throw new UserInputException("Url could not be null");
			}
			/*load jdbc*/
		}

		Через запятую можно указать несколько исключений. В этом случае мы передаем ответственность за исключение коду, который будет использовать наш метод.
		
		Другой вариант - это использование конструкции try-catch.

		Конструкция try-catch. 

		Эта конструкция позволяет выполнить методы, которые могут прерваться с исключением и обработать эти исключения.

		Давайте в методе main выполним метод load в блоке try-catch.

		public static void main(String[] args) {
			try {
				load("jdbc://localhost:8080");
			} catch (UserInputException e) {
				e.printStackTrace();
			}
		}

		Мы убрали из сигнатуры объявление throws и обернули метод load в конструкцию try-catch.

		Блок try содержит операторы, которые мы хотим выполнить.

		Блок catch содержит объявление исключение. Если операторы в блоке try вызовут исключение UserInputException, то программа перейдет к выполнению блока catch.

		В блоке catch написан только один оператор.

		e.printStackTrace();

		Этот оператор выведет на консоль стек вызовов методов от начала программы до оператора, который вызвал прерывания. 

		В большинстве случаев ваш код с блоком catch будет выглядеть так же.
	
26. Назовите основные методы класса Object?
	Методы класса Object в Java:

    protected Object clone() - создает новый объект, не отличающийся от клонируемого.
    public boolean equals(Object obj) - определяет, равен ли один объект другому.
    protected void finalize() - вызывается перед удалением неиспользуемого объекта.
    public final Class<?> getClass() - получает класс объекта во время выполнения.
    public int hashCode() - возвращает хэш-код, связанный с вызывающим объектом.
    public final void notify() - возобновляет исполнение потока, ожидающего вызывающего объекта.
    public final void notifyAll() - возобновляет исполнение всех потоков, ожидающих вызывающего объекта.
    public String toString() - возвращает символьную строку, описывающую объект.
    public final void wait() - ожидает другого потока исполнения.
    public final void wait(long timeout) - ожидает другого потока исполнения.
    public final void wait(long timeout, int nanos) - ожидает другого потока исполнения.
	
	Еще вариант ответа
	

    public native int hashCode() — возвращает хеш-код объекта.

    public boolean equals(Object obj) — сравнивает объекты.

    public String toString() — возвращает строковое представление объекта.

    public final native Class getClass() — возвращает в рантайме класс данного объекта.

    protected native Object clone() throws CloneNotSupportedException — клонирование объекта

    public final native void notify() — просыпается один поток, который ждет на "мониторе" данного объекта.

    public final native void notifyAll() — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

    public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.

    public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.

    public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.

    protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

    Модификатор native сигнализирует о том, что метод реализован в платформо-зависимом коде, часто на языке С.



27. Что такое шаблоны проектирования?
			Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста. Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях.
			https://github.com/enhorse/java-interview/blob/master/patterns.md
			
28. Объясните шаблон - декоратор.

Декоратор — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.
https://java-ru-blog.blogspot.com/2020/02/decorator-pattern-java.html
адаптер
https://java-ru-blog.blogspot.com/2020/02/pattern-adapter-java.html
Паттерн Builder (Строитель)
https://java-ru-blog.blogspot.com/2019/10/builder-pattern-java.html

29. Объясните шаблон - стратегия.

	Стратегия — это поведенческий паттерн, выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.

	Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект другим, если требуется иной способ решения задачи.
	Стратегия часто используется в Java-коде, особенно там, где нужно подменять алгоритм во время выполнения программы. Начиная с Java 8, многие примеры стратегии можно заменить простыми lambda-выражениями.
	
	Паттерн Стратегия (Strategy) относится к поведенческим (behavioral) паттернам проектирования. Также известен как Политика (Policy).

Основным замыслом паттерна является следующая ситуация. Вы определяете семейство алгоритмов, инкапсулируете каждый и делаете их взаимозаменяемыми. Стратегия позволяет алгоритму варьироваться независимо от клиентов, которые используют его.

Используйте шаблон стратегии, когда

    многие связанные классы отличаются только своим поведением. Стратегии предоставляют способ настроить класс на одно из многих поведений
    вам нужны разные варианты алгоритма. Например, вы можете определить алгоритмы, отражающие различные компромиссы пространства/времени. Стратегии могут использоваться, когда эти варианты реализованы в виде иерархии классов алгоритмов.
    алгоритм использует данные, о которых клиенты не должны знать. Используйте паттерн Стратегия, чтобы избежать выявления сложных, специфичных для алгоритма структур данных.
    класс определяет много поведений, и они появляются как несколько условных операторов в своих операциях. Вместо многих условных выражений перенесите соответствующие условные ветви в свой собственный класс Strategy.
https://java-ru-blog.blogspot.com/2020/02/strategy-pattern-java.html

30 Sungelton

			Все шаблоны проектирования строятся на принципах ООП. Важно понимать, что шаблоны проектирования это не готовые программы, а примеры решений конкретных задач.

			Шаблон singleton - используется для создания класса, который может содержать только один экземпляр объекта в виртуальной машине.

			Шаблон singleton применяют в проектах, где используются внешние ресурсы: файловая система, база данных, связь с другими приложениями.

			В таких проектах доступ к ресурсу нужно ограничить использованием одного объекта на виртуальную машину.

			Это позволяет экономить ресурсы системы.
			Чтобы начать использовать этот класс, нам нужно создать объект этого класса. Но в этом случае каждый объект класса Log4File будет содержать свои данные.

			Чтобы такой проблемы не было нам нужно.

			1. Создать явно конструктор и указать у него модификатор private. Таким образом, никто не сможет создать объект этого класса.

			2. Так же нужно запретить наследование этого класса. Для этого используем ключевое слово final.
			3. Вы спросите, а какой же тогда смысл в этом классе, если никто не может использовать его методы?

			На самом деле мы можем создать объект этого класса внутри самого класса. 

			Остается один момент, а как дать ссылку на этот объект? У нас есть ключевое слово static, его можно использовать для полей класса.

			Если поле обозначено static, то оно привязано к классу, а не к объекту. Это позволяет сохранить ссылку на объект класса Log4File.

			Так же добавим public static метод, чтобы другие классы могли получить ссылку на объект Log4File.

			Доработаем код.
			package ru.job4j.memTracker;

			public final class Log4File {

				private static Log4File instance = null;

				private String[] messages = new String[1000];
				private int index = 0;

				private Log4File() {
				}

				public static Log4File getInstance() {
					if (instance == null) {
						instance = new Log4File();
					}
					return instance;
				}

				public void add(String message) {
					messages[index++] = message;
				}

				public void save() {
					//TODO Сохраняем записи из массива messages в файл.
				}
			}
			При первом вызове метод getInstance() программа проверяет заполнено ли поле instance.

			Если оно не заполнено, то мы создаем объект класса Log4File и записываем его в статическое поле.
			https://habr.com/ru/post/129494/

31 Наследование, композиция и агрегация

			По моей практике преподавания вопрос отношений между классами (или объектами) почему-то вызывает проблемы. Из-за чего так происходит, не могу сказать. Когда я изучал ООП, мне это показалось настолько очевидным, что не стоило даже упоминания — вся логика ООП не просто кричит, она вопиет об очевидности таких отношений и правилах их построения. Но тем не менее этот вопрос часто требует объяснений. Чем мы сейчас и займемся, прежде чем продолжим изучение новых конструкций языка Java.

			Теоия ООП выделяет три основных отношения между классами:

				Ассоциация
				Агрегация и композиция
				Обобщение/Расширение (наследование)

			Последний пункт мы с вами уже рассматривали, так что сосредоточимся на первых двух.

			 
			Ассоциация

			Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.
			Агрегация и композиция

			Агрегация и композиция на самом деле являются частными случаями ассоциации. Это более конкретизированные отношения между объектами.
			Агрегация — отношение когда один объект является частью другого. Например Студент входит в Группу любителей физики.
			Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. Такие описания всегда несколько условны, но тем не менее.

http://java-course.ru/begin/relations/

